<!DOCTYPE html>
<html>
<head>
    <title>Indian Delivery Madness 3D</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
    <script>
        // Check for WebGL support
        if (!window.WebGLRenderingContext) {
            alert('Your browser does not support WebGL. Please use a modern browser.');
        }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1C1C1C;
            overflow: hidden;
            touch-action: none;
        }
        #score {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial;
            font-size: 24px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #E23744;
        }
        #timer {
            position: fixed;
            top: 70px;
            left: 20px;
            color: white;
            font-family: Arial;
            font-size: 24px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #FFD700;
        }
        #title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #E23744;
            font-family: Arial;
            font-size: 32px;
            font-weight: bold;
            z-index: 100;
            text-shadow: 2px 2px #000;
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            #title {
                font-size: 24px;
            }
            #score, #timer {
                font-size: 18px;
                padding: 8px 16px;
            }
            .modal {
                width: 90%;
                max-width: 400px;
            }
            #message-queue {
                left: 50% !important;
                transform: translateX(-50%) !important;
                bottom: 160px !important;  /* Position above the joystick */
                top: auto !important;
                width: 90% !important;
                max-width: 300px !important;
                background: rgba(0, 0, 0, 0.6);
                padding: 8px !important;
                border-radius: 12px;
                z-index: 1001;
            }
            #highScoreBtn, #shareButton {
                padding: 6px 12px !important;
                font-size: 14px !important;
            }
        }

        /* Virtual joystick container */
        #joystick-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            z-index: 1000;
            touch-action: none;
            display: none; /* Hidden by default, shown on mobile */
        }

        /* Show joystick only on mobile devices */
        @media (max-width: 768px) {
            #joystick-container {
                display: block;
            }
        }
        #combo {
            position: fixed;
            top: 60px;
            left: 20px;
            color: #FFD700;
            font-family: Arial;
            font-size: 20px;
            z-index: 100;
        }
        #delivery-type {
            display: none;  /* Hide the old delivery-type element as we'll use chat box instead */
        }
        #direction-arrow {
            display: none;
        }

        #distance-indicator {
            display: none;
        }

        @keyframes pulse {
            0% { transform: scale(1) rotate(var(--arrow-rotation)); }
            50% { transform: scale(1.1) rotate(var(--arrow-rotation)); }
            100% { transform: scale(1) rotate(var(--arrow-rotation)); }
        }

        .effect {
            position: fixed;
            pointer-events: none;
            z-index: 99;
        }
        #city-selector {
            position: fixed;
            top: 20px;
            right: 380px;
            padding: 8px 16px;
            background: #E23744;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
            font-family: Arial;
        }

        #event-selector {
            position: fixed;
            top: 20px;
            right: 520px;
            padding: 8px 16px;
            background: #FFD700;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
            font-family: Arial;
        }

        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 15px;
            color: white;
            z-index: 1000;
            font-family: Arial;
        }

        .modal h2 {
            color: #E23744;
            margin-top: 0;
        }

        .modal-option {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .modal-option:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .modal-option img {
            width: 50px;
            height: 50px;
            margin-right: 15px;
            border-radius: 5px;
        }

        .modal-option .details {
            flex-grow: 1;
        }

        .modal-option h3 {
            margin: 0;
            color: #FFD700;
        }

        .modal-option p {
            margin: 5px 0 0;
            font-size: 14px;
            opacity: 0.8;
        }

        .close-modal {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }

        #achievements-panel {
            position: fixed;
            right: -300px;
            top: 50%;
            transform: translateY(-50%);
            width: 280px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px 0 0 15px;
            transition: right 0.3s;
            z-index: 100;
        }

        #achievements-panel.show {
            right: 0;
        }

        .achievement-item {
            background: rgba(255, 255, 255, 0.1);
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            color: white;
        }

        .achievement-item h3 {
            margin: 0;
            color: #FFD700;
        }

        .achievement-item p {
            margin: 5px 0 0;
            font-size: 14px;
            opacity: 0.8;
        }

        #message-queue {
            position: fixed;
            left: 20px;
            top: 150px;
            width: 300px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
            font-family: 'Arial', sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(8px);
            max-height: 400px;
            overflow-y: auto;
        }

        .message {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-left: 4px solid;
            backdrop-filter: blur(8px);
            max-width: 280px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            #message-queue {
                left: 50% !important;
                transform: translateX(-50%) !important;
                bottom: 160px !important;  /* Position above the joystick */
                top: auto !important;
                width: 90% !important;
                max-width: 300px !important;
                background: rgba(0, 0, 0, 0.6);
                padding: 8px !important;
                border-radius: 12px;
                z-index: 1001;
            }

            .message {
                font-size: 12px !important;
                padding: 8px 12px !important;
                margin-bottom: 4px !important;
                max-width: 100% !important;
            }

            /* Hide timestamp on mobile to save space */
            .message .timestamp {
                display: none !important;
            }
        }

        #camera-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 10px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        .camera-btn {
            background: #E23744;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial;
            font-weight: bold;
            transition: background 0.3s;
        }

        .camera-btn:hover {
            background: #FF4757;
        }

        .camera-btn.active {
            background: #2ED573;
        }

        /* Add new styles for the username modal */
        #username-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            color: white;
            z-index: 2000;
            text-align: center;
            font-family: Arial;
            border: 2px solid #E23744;
        }

        #username-modal h2 {
            color: #E23744;
            margin-bottom: 20px;
        }

        #username-modal input {
            padding: 10px;
            margin: 10px 0;
            width: 200px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
        }

        #username-modal button {
            padding: 10px 20px;
            margin-top: 15px;
            background: #E23744;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        #username-modal button:hover {
            background: #FF4757;
        }

        /* Add blinking animation */
        @keyframes blink {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.3; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }

        @keyframes float {
            0% { transform: translateY(0); }
            50% { transform: translateY(-0.5px); }
            100% { transform: translateY(0); }
        }

        /* Add marker styles */
        .location-marker {
            animation: blink 1.5s infinite ease-in-out;
        }
    </style>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.x.x/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.x.x/firebase-database-compat.js"></script>
    <script>
        // Replace this entire firebaseConfig object with the one from your Firebase Console
        // To get this:
        // 1. Go to Firebase Console
        // 2. Click on the gear icon next to "Project Overview"
        // 3. Click "Project Settings"
        // 4. Scroll down to "Your apps" section
        // 5. Copy the firebaseConfig object
        const firebaseConfig = {
            apiKey: "REPLACE_WITH_YOUR_API_KEY",
            authDomain: "REPLACE_WITH_YOUR_AUTH_DOMAIN",
            databaseURL: "REPLACE_WITH_YOUR_DATABASE_URL",
            projectId: "REPLACE_WITH_YOUR_PROJECT_ID",
            storageBucket: "REPLACE_WITH_YOUR_STORAGE_BUCKET",
            messagingSenderId: "REPLACE_WITH_YOUR_MESSAGING_SENDER_ID",
            appId: "REPLACE_WITH_YOUR_APP_ID"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();
    </script>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="timer">Time: 60</div>
    <div id="title">Indian Delivery Madness 3D</div>
    <div id="combo"></div>
    <div id="message-queue"></div>
    <div id="achievements-panel">
        <h2>Achievements</h2>
        <div id="achievements-list"></div>
    </div>
    <script>
        // Add debug logging
        console.log('Starting game initialization...');

        // Check if Three.js is loaded
        if (typeof THREE === 'undefined') {
            console.error('Three.js failed to load');
            document.body.innerHTML += '<div style="color: white; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: Arial;">Failed to load 3D engine. Please check your internet connection and refresh.</div>';
            throw new Error('Three.js not loaded');
        }

        // Test WebGL compatibility
        try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) {
                throw new Error('WebGL not supported');
            }
        } catch (e) {
            console.error('WebGL error:', e);
            document.body.innerHTML += '<div style="color: white; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: Arial;">Your browser does not support 3D graphics. Please use a modern browser.</div>';
            throw e;
        }

        let scene, camera, renderer, player;
        let deliveryTargets = [], obstacles = [], powerUps = [];
        let specialObstacles = [];
        let messageQueue = [];  // Moved to top with other global variables
        let achievements = [];  // Initialize achievements array
        const MAX_MESSAGES = 5;
        let gameState = {
            score: 0,
            timeLeft: 60,
            combo: 0,
            comboTimer: 0,
            pointMultiplier: 1,
            isInvulnerable: false
        };

        const COLORS = {
            PRIMARY: 0xE23744,    // Zomato red
            SECONDARY: 0x1C1C1C,  // Dark gray
            ACCENT: 0xCB202D,     // Dark red
            OBSTACLE: 0xFF4444,   // Warning red
            AUTO: 0xFED350,       // Auto yellow (more Indian)
            COW: 0xFFFFFF,        // Cow white
            VENDOR: 0xFF9933,     // Saffron for vendors
            ROAD: 0x666666,       // Indian street color
            BUILDING: 0xFFF5E1    // Cream color for buildings
        };

        // Add food types and restaurants
        const FOOD_TYPES = [
            { name: "Butter Chicken", color: 0xE23744, points: 15, restaurant: "Empire Restaurant" },
            { name: "Hyderabadi Biryani", color: 0xFFD700, points: 20, restaurant: "Meghana Foods" },
            { name: "Masala Dosa", color: 0xDEB887, points: 12, restaurant: "CTR" },
            { name: "Andhra Meals", color: 0xF0E68C, points: 15, restaurant: "Nagarjuna" },
            { name: "Chinese", color: 0xCD853F, points: 10, restaurant: "Beijing Bites" },
            { name: "Quick Commerce", color: 0x32CD32, points: 25, restaurant: function() {
                const stores = ["Blinkit", "Zepto", "Instamart"];
                return stores[Math.floor(Math.random() * stores.length)];
            }() }
        ];

        // Add nextRestaurant variable at the top with other game state variables
        let currentDelivery = null;
        let restaurants = [];
        let houses = [];
        let consecutiveDeliveries = 0;
        let targetHouse = null;
        let nextRestaurant = null;  // Track the next restaurant to pick up from

        // Add high score system
        let highScores = [];  // Initialize as empty array
        let playerUsername = '';
        
        // Add function to show username modal
        function showUsernameModal() {
            const modal = document.createElement('div');
            modal.id = 'username-modal';
            modal.style.width = isMobile() ? '90%' : 'auto';
            modal.style.maxWidth = '400px';
            modal.innerHTML = `
                <h2>Welcome to Indian Delivery Madness!</h2>
                <p>Please enter your name to start playing:</p>
                <input type="text" id="username-input" maxlength="15" placeholder="Enter your name">
                <div style="margin: 20px 0; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px; text-align: left; font-size: ${isMobile() ? '12px' : '14px'};">
                    <h3 style="color: #FFD700; margin-bottom: 10px;">üõµ How to Play:</h3>
                    <ul style="list-style: none; padding: 0; margin: 0;">
                        <li>${isMobile() ? 'üïπÔ∏è Use the virtual joystick to drive' : 'üéÆ Use Arrow Keys to drive your delivery bike'}</li>
                        <li>üè™ Look for restaurants with blue arrows</li>
                        <li>üèÉ Deliver orders to houses with green arrows</li>
                        <li>‚ö†Ô∏è Watch out for cows, auto-rickshaws, and traffic!</li>
                        <li>üåü Chain deliveries for bonus points</li>
                        <li>üçñ Quick Commerce = Fast Points!</li>
                        <li>üí® You have 60 seconds - Make it count!</li>
                    </ul>
                </div>
                <button id="start-game-btn">Start Delivering!</button>
            `;
            document.body.appendChild(modal);

            const input = document.getElementById('username-input');
            const button = document.getElementById('start-game-btn');

            input.focus();

            function handleStart() {
                const username = input.value.trim();
                if (username) {
                    playerUsername = username;
                    document.body.removeChild(modal);
                    init(); // Start the game
                } else {
                    input.style.border = '2px solid red';
                    input.placeholder = 'Name is required';
                }
            }

            button.onclick = handleStart;
            input.onkeypress = (e) => {
                if (e.key === 'Enter') {
                    handleStart();
                }
            };
        }

        // Update saveHighScore function to include username
        function saveHighScore(score) {
            try {
                if (!playerUsername) {
                    console.warn('No username provided, using "Anonymous"');
                    playerUsername = 'Anonymous';
                }

                // Create new score entry
                const newScore = {
                    username: playerUsername,
                    score: score
                };

                // Get existing scores
                let highScores = [];
                const savedScores = localStorage.getItem('zomatoHighScores');
                if (savedScores) {
                    try {
                        highScores = JSON.parse(savedScores);
                        // Validate existing scores
                        highScores = highScores.filter(score => 
                            score && typeof score === 'object' && 
                            'username' in score && 
                            'score' in score
                        );
                    } catch (e) {
                        console.error('Error parsing saved scores:', e);
                        highScores = [];
                    }
                }

                // Add new score
                highScores.push(newScore);

                // Sort by score (highest first)
                highScores.sort((a, b) => b.score - a.score);

                // Keep only top 5
                highScores = highScores.slice(0, 5);

                // Save back to localStorage
                localStorage.setItem('zomatoHighScores', JSON.stringify(highScores));
                console.log('Saved high scores:', highScores);
            } catch (e) {
                console.error('Error saving high score:', e);
            }
        }

        // Update showHighScores function to display usernames
        function showHighScores() {
            try {
                // Get and parse high scores
                let highScores = [];
                const savedScores = localStorage.getItem('zomatoHighScores');
                if (savedScores) {
                    try {
                        highScores = JSON.parse(savedScores);
                        // Validate scores
                        highScores = highScores.filter(score => 
                            score && typeof score === 'object' && 
                            'username' in score && 
                            'score' in score
                        );
                    } catch (e) {
                        console.error('Error parsing saved scores:', e);
                        highScores = [];
                    }
                }

                // Create high scores display
                const scoresDiv = document.createElement('div');
                scoresDiv.style.position = 'fixed';
                scoresDiv.style.top = '50%';
                scoresDiv.style.left = '50%';
                scoresDiv.style.transform = 'translate(-50%, -50%)';
                scoresDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
                scoresDiv.style.padding = '30px';
                scoresDiv.style.borderRadius = '15px';
                scoresDiv.style.color = 'white';
                scoresDiv.style.fontSize = '24px';
                scoresDiv.style.fontFamily = 'Arial';
                scoresDiv.style.textAlign = 'center';
                scoresDiv.style.minWidth = '400px';
                scoresDiv.style.zIndex = '1000';

                let content = '<h2 style="color: #E23744; margin-bottom: 20px;">High Scores</h2>';

                if (!highScores || highScores.length === 0) {
                    content += '<p style="color: #FFD700;">No high scores yet!</p>';
                } else {
                    content += '<div style="margin-bottom: 20px;">';
                    highScores.forEach((entry, index) => {
                        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : '';
                        const username = entry.username || 'Anonymous';
                        const score = typeof entry.score === 'number' ? entry.score : 0;
                        
                        content += `
                            <div style="
                                margin: 10px 0;
                                padding: 10px;
                                background: ${index === 0 ? 'rgba(255, 215, 0, 0.2)' : 'rgba(255, 255, 255, 0.1)'};
                                border-radius: 8px;
                                font-size: 20px;
                            ">
                                ${medal} ${username} - ${score} points
                            </div>`;
                    });
                    content += '</div>';
                }

                content += `
                    <button id="closeScores" style="
                        padding: 10px 20px;
                        background: #E23744;
                        border: none;
                        color: white;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 16px;
                        margin-top: 10px;
                    ">Close</button>`;

                scoresDiv.innerHTML = content;
                document.body.appendChild(scoresDiv);

                document.getElementById('closeScores').onclick = () => {
                    document.body.removeChild(scoresDiv);
                };
            } catch (e) {
                console.error('Error showing high scores:', e);
                showMessage('Error displaying high scores', '#FF4444');
            }
        }

        // Add traffic system
        let vehicles = [];
        const VEHICLE_TYPES = [
            { name: 'car', width: 1.2, length: 2.5, color: 0x4444FF },
            { name: 'truck', width: 1.5, length: 3.5, color: 0x44FF44 },
            { name: 'bike', width: 0.8, length: 1.8, color: 0xFF4444 }
        ];

        function createRestaurant(foodType) {
            const restaurant = new THREE.Group();
            
            // Main building - reduced by 50%
            const buildingGeometry = new THREE.BoxGeometry(1.5, 1.25, 1.5);
            const buildingMaterial = new THREE.MeshStandardMaterial({ 
                color: foodType.name === "Quick Commerce" ? 0xFFD700 : 0x990000,
                metalness: 0.1,
                roughness: 0.9
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            
            // Add windows - reduced by 50%
            const windowGeometry = new THREE.PlaneGeometry(0.25, 0.4);
            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x88CCFF,
                metalness: 0.5,
                roughness: 0.2
            });
            
            // Front windows - adjusted positions
            [-0.4, 0.4].forEach(x => {
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(x, 0, 0.76);
                building.add(window);
            });

            // Side windows - adjusted positions
            [-0.4, 0.4].forEach(x => {
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(0.76, 0, x);
                window.rotation.y = Math.PI / 2;
                building.add(window);
            });

            // Door - reduced by 50%
            const doorGeometry = new THREE.PlaneGeometry(0.4, 0.8);
            const doorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                metalness: 0.3,
                roughness: 0.7
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, -0.2, 0.76);
            building.add(door);

            // Restaurant sign - reduced by 50%
            const signGroup = new THREE.Group();
            
            // Sign background
            const signGeometry = new THREE.BoxGeometry(1.6, 0.4, 0.1);
            const signMaterial = new THREE.MeshStandardMaterial({ 
                color: foodType.color,
                metalness: 0.3,
                roughness: 0.7
            });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            signGroup.add(sign);

            // Sign border
            const borderGeometry = new THREE.BoxGeometry(1.7, 0.5, 0.05);
            const borderMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF,
                metalness: 0.5,
                roughness: 0.5
            });
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.position.z = -0.05;
            signGroup.add(border);

            signGroup.position.set(0, 0.75, 0.8);
            restaurant.add(signGroup);

            // Add awning - reduced by 50%
            const awningGeometry = new THREE.CylinderGeometry(0.25, 0.25, 1.6, 8, 1, false, 0, Math.PI);
            const awningMaterial = new THREE.MeshStandardMaterial({ 
                color: foodType.color,
                metalness: 0.1,
                roughness: 0.9,
                side: THREE.DoubleSide
            });
            const awning = new THREE.Mesh(awningGeometry, awningMaterial);
            awning.rotation.z = Math.PI / 2;
            awning.rotation.y = Math.PI / 2;
            awning.position.set(0, 0.4, 0.75);
            restaurant.add(awning);

            // Add decorative elements - reduced by 50%
            const plantGeometry = new THREE.CylinderGeometry(0.1, 0.075, 0.2, 8);
            const plantMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const potMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

            [-0.6, 0.6].forEach(x => {
                const pot = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.075, 0.1, 0.15, 8),
                    potMaterial
                );
                const plant = new THREE.Mesh(plantGeometry, plantMaterial);
                plant.position.y = 0.15;
                
                const plantGroup = new THREE.Group();
                plantGroup.add(pot);
                plantGroup.add(plant);
                plantGroup.position.set(x, -0.625, 0.6);
                restaurant.add(plantGroup);
            });

            // Add base building to restaurant group
            restaurant.add(building);
            
            // Position along the roads
            const roadSpacing = 8;
            const roadOffset = 3;
            const maxOffset = 19;  // Increased from 15 to 19
            
            // Choose a random road intersection with larger range
            const x = (Math.floor(Math.random() * 5) - 2) * roadSpacing;  // Increased range
            const z = (Math.floor(Math.random() * 5) - 2) * roadSpacing;  // Increased range
            
            // Randomly offset from intersection with bounds checking
            const side = Math.random() < 0.5 ? -1 : 1;
            const isHorizontal = Math.random() < 0.5;
            
            if (isHorizontal) {
                restaurant.position.x = Math.max(-maxOffset, Math.min(maxOffset, x + (Math.random() * 4 - 2)));
                restaurant.position.z = Math.max(-maxOffset, Math.min(maxOffset, z + (side * roadOffset)));
            } else {
                restaurant.position.x = Math.max(-maxOffset, Math.min(maxOffset, x + (side * roadOffset)));
                restaurant.position.z = Math.max(-maxOffset, Math.min(maxOffset, z + (Math.random() * 4 - 2)));
            }
            
            restaurant.position.y = 0.625; // Reduced height by 50%
            
            // Rotate to face the road
            if (isHorizontal) {
                restaurant.rotation.y = side > 0 ? Math.PI : 0;
            } else {
                restaurant.rotation.y = side > 0 ? -Math.PI/2 : Math.PI/2;
            }
            
            restaurant.foodType = foodType;
            restaurant.isPickupPoint = true;
            
            scene.add(restaurant);
            restaurants.push(restaurant);
        }

        function createHouse() {
            const house = new THREE.Group();
            
            // Main building
            const buildingGeometry = new THREE.BoxGeometry(2, 2, 2);
            const buildingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xF5F5F5,  // White walls
                metalness: 0.1,
                roughness: 0.9
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            
            // Roof (more detailed)
            const roofGeometry = new THREE.ConeGeometry(1.8, 1.2, 4);
            const roofMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,  // Brown roof
                metalness: 0.2,
                roughness: 0.8
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 1.6;
            roof.rotation.y = Math.PI / 4;
            house.add(roof);

            // Add windows
            const windowGeometry = new THREE.PlaneGeometry(0.4, 0.6);
            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x87CEEB,  // Sky blue
                metalness: 0.5,
                roughness: 0.2
            });
            
            // Front windows
            [-0.5, 0.5].forEach(x => {
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(x, 0.2, 1.01);
                building.add(window);
            });

            // Side windows
            [-0.5, 0.5].forEach(x => {
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(1.01, 0.2, x);
                window.rotation.y = Math.PI / 2;
                building.add(window);
            });

            // Door
            const doorGeometry = new THREE.PlaneGeometry(0.6, 1.2);
            const doorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,  // Brown door
                metalness: 0.3,
                roughness: 0.7
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, -0.4, 1.01);
            building.add(door);

            // Add doorstep
            const stepGeometry = new THREE.BoxGeometry(0.8, 0.1, 0.4);
            const stepMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x808080,  // Gray steps
                metalness: 0.2,
                roughness: 0.8
            });
            const step = new THREE.Mesh(stepGeometry, stepMaterial);
            step.position.set(0, -0.95, 1.2);
            building.add(step);

            // Add chimney
            const chimneyGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const chimneyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,  // Brown chimney
                metalness: 0.2,
                roughness: 0.9
            });
            const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
            chimney.position.set(0.6, 1.8, 0.6);
            house.add(chimney);

            // Add some decorative elements
            const bushGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const bushMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,  // Forest green
                metalness: 0.1,
                roughness: 0.9
            });

            // Add bushes in front of the house
            [-0.8, 0.8].forEach(x => {
                const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                bush.position.set(x, -0.7, 1);
                bush.scale.set(1, 0.7, 0.7);
                house.add(bush);
            });

            // Add house number
            const houseNumberGeometry = new THREE.PlaneGeometry(0.3, 0.2);
            const houseNumberMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,  // Gold
                metalness: 0.6,
                roughness: 0.4
            });
            const houseNumber = new THREE.Mesh(houseNumberGeometry, houseNumberMaterial);
            houseNumber.position.set(-0.8, 0.5, 1.02);
            building.add(houseNumber);

            // Add marker arrow above house (keep existing functionality)
            const arrowGeometry = new THREE.ConeGeometry(0.3, 0.6, 4);
            const arrowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,
                transparent: true,
                opacity: 0
            });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.position.y = 3;
            arrow.rotation.x = Math.PI;
            house.arrow = arrow;
            house.add(arrow);

            house.add(building);
            
            // Position along the roads
            const roadSpacing = 8;
            const roadOffset = 3;
            const maxOffset = 19;  // Increased from 15 to 19
            
            // Choose a random road intersection with larger range
            const x = (Math.floor(Math.random() * 5) - 2) * roadSpacing;  // Increased range
            const z = (Math.floor(Math.random() * 5) - 2) * roadSpacing;  // Increased range
            
            // Randomly offset from intersection with bounds checking
            const side = Math.random() < 0.5 ? -1 : 1;
            const isHorizontal = Math.random() < 0.5;
            
            if (isHorizontal) {
                house.position.x = Math.max(-maxOffset, Math.min(maxOffset, x + (Math.random() * 4 - 2)));
                house.position.z = Math.max(-maxOffset, Math.min(maxOffset, z + (side * roadOffset)));
            } else {
                house.position.x = Math.max(-maxOffset, Math.min(maxOffset, x + (side * roadOffset)));
                house.position.z = Math.max(-maxOffset, Math.min(maxOffset, z + (Math.random() * 4 - 2)));
            }
            
            house.position.y = 1;
            
            // Rotate to face the road
            if (isHorizontal) {
                house.rotation.y = side > 0 ? Math.PI : 0;
            } else {
                house.rotation.y = side > 0 ? -Math.PI/2 : Math.PI/2;
            }
            
            house.isDeliveryPoint = true;
            house.isHighlighted = false;
            
            scene.add(house);
            houses.push(house);
            return house;
        }

        function highlightTargetHouse(house) {
            // Reset all houses
            houses.forEach(h => {
                if (h.arrow) {
                    scene.remove(h.arrow);
                    h.arrow = null;
                }
                if (h.outline) {
                    scene.remove(h.outline);
                    h.outline = null;
                }
            });

            if (house) {
                // Add enhanced green arrow above house
                const arrowGeometry = new THREE.ConeGeometry(0.5, 1.0, 6); // Larger arrow
                const arrowMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00FF00,  // Bright green
                    metalness: 0.5,
                    roughness: 0.5,
                    transparent: true,
                    opacity: 1,
                    emissive: 0x00FF00,
                    emissiveIntensity: 1
                });
                const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                arrow.position.copy(house.position);
                arrow.position.y = 3.5;  // Slightly higher
                arrow.rotation.x = Math.PI;
                scene.add(arrow);
                house.arrow = arrow;

                // Add enhanced outline effect
                const outlineGeometry = new THREE.BoxGeometry(2.6, 2.6, 2.6);
                const outlineMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00FF00,  // Bright green
                    side: THREE.BackSide,
                    transparent: true,
                    opacity: 0.7
                });
                const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
                outline.position.copy(house.position);
                outline.scale.set(1.3, 1.3, 1.3);  // Larger initial scale
                scene.add(outline);
                house.outline = outline;

                // Add animation properties
                arrow.userData.animationOffset = Math.random() * Math.PI * 2;
                outline.userData.animationOffset = Math.random() * Math.PI * 2;
            }
        }

        // Initialize Three.js scene
        function init() {
            try {
                console.log('Initializing Three.js...');
                
                // Create message queue container if it doesn't exist
                if (!document.getElementById('message-queue')) {
                    const messageContainer = document.createElement('div');
                    messageContainer.id = 'message-queue';
                    messageContainer.style.position = 'fixed';
                    messageContainer.style.left = '20px';
                    messageContainer.style.top = '150px';
                    messageContainer.style.width = '400px';
                    messageContainer.style.zIndex = '1000';
                    document.body.appendChild(messageContainer);
                }

                // Add joystick container for mobile
                if (!document.getElementById('joystick-container')) {
                    const joystickContainer = document.createElement('div');
                    joystickContainer.id = 'joystick-container';
                    document.body.appendChild(joystickContainer);
                }
                
                // Initialize joystick for mobile
                if (isMobile()) {
                    const joystick = nipplejs.create({
                        zone: document.getElementById('joystick-container'),
                        mode: 'static',
                        position: { left: '50%', top: '50%' },
                        color: 'white',
                        size: 120,
                        lockX: false,
                        lockY: false,
                        dynamicPage: true
                    });

                    let joystickData = {
                        angle: 0,
                        force: 0,
                        moving: false
                    };

                    joystick.on('move', (evt, data) => {
                        joystickData.moving = true;
                        joystickData.angle = data.angle.radian;
                        joystickData.force = Math.min(data.force, 1);

                        // Convert angle to normalized direction vector
                        const directionX = Math.cos(joystickData.angle);
                        const directionZ = -Math.sin(joystickData.angle);  // Negative because Z is inverted in our coordinate system

                        // Update player rotation to face movement direction
                        player.rotation.y = -joystickData.angle + Math.PI/2;

                        // Apply movement based on direction and force
                        const speed = 0.2 * joystickData.force;
                        player.position.x += directionX * speed;
                        player.position.z += directionZ * speed;

                        // Update camera to follow player
                        camera.position.x = player.position.x;
                        camera.position.z = player.position.z + 8;
                        camera.position.y = 18;
                        camera.lookAt(player.position.x, 0, player.position.z - 2);
                    });

                    joystick.on('end', () => {
                        joystickData.moving = false;
                        joystickData.force = 0;
                    });
                }

                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1C1C1C);
                console.log('Scene created');

                // Create camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 20, 15); // Higher up for better overview
                camera.lookAt(0, 0, 0);
                camera.rotation.z = 0;
                console.log('Camera created');

                // Create renderer with error handling
                try {
                    renderer = new THREE.WebGLRenderer({ 
                        antialias: true,
                        alpha: true,
                        powerPreference: "high-performance"
                    });
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.setClearColor(0x1C1C1C, 1);
                    document.body.appendChild(renderer.domElement);
                    console.log('Renderer created');
                } catch (rendererError) {
                    console.error('Failed to create renderer:', rendererError);
                    document.body.innerHTML += '<div style="color: white; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: Arial;">Failed to initialize 3D graphics. Please ensure your browser supports WebGL.</div>';
                    return;
                }

                // Add lights with more intensity
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);
                console.log('Lights added');

                // Create and add ground with Indian street texture
                const ground = createGround();
                scene.add(ground);

                // Add roads in a grid pattern
                const roadWidth = 2; // Reduced from 3 to 2
                const roadSpacing = 8;
                const roadMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1C1C1C,  // Darker asphalt color
                    roughness: 0.7,
                    metalness: 0.2
                });

                // Create horizontal roads with adjusted spacing
                for (let i = -15; i <= 15; i += roadSpacing) {
                    const horizontalRoadGeometry = new THREE.PlaneGeometry(40, roadWidth);
                    const horizontalRoad = new THREE.Mesh(horizontalRoadGeometry, roadMaterial);
                    horizontalRoad.rotation.x = -Math.PI / 2;
                    horizontalRoad.position.z = i;
                    horizontalRoad.position.y = 0.01;  // Slightly raised to prevent z-fighting
                    scene.add(horizontalRoad);

                    // Add road markings with increased visibility
                    for (let x = -16; x <= 16; x += 5) {
                        const line = new THREE.Mesh(
                            new THREE.PlaneGeometry(1, 0.15),
                            new THREE.MeshStandardMaterial({
                                color: 0xFFFFFF,
                                roughness: 0.3,
                                metalness: 0.4,
                                emissive: 0xFFFFFF,
                                emissiveIntensity: 0.1
                            })
                        );
                        line.rotation.x = -Math.PI / 2;
                        line.position.set(x, 0.02, i);  // Slightly raised above road
                        scene.add(line);
                    }
                }

                // Create vertical roads with adjusted spacing
                for (let i = -15; i <= 15; i += roadSpacing) {
                    const verticalRoadGeometry = new THREE.PlaneGeometry(roadWidth, 40);
                    const verticalRoad = new THREE.Mesh(verticalRoadGeometry, roadMaterial);
                    verticalRoad.rotation.x = -Math.PI / 2;
                    verticalRoad.position.x = i;
                    verticalRoad.position.y = 0.01;  // Slightly raised to prevent z-fighting
                    scene.add(verticalRoad);

                    // Add road markings with increased visibility
                    for (let z = -16; z <= 16; z += 5) {
                        const line = new THREE.Mesh(
                            new THREE.PlaneGeometry(1, 0.15),
                            new THREE.MeshStandardMaterial({
                                color: 0xFFFFFF,
                                roughness: 0.3,
                                metalness: 0.4,
                                emissive: 0xFFFFFF,
                                emissiveIntensity: 0.1
                            })
                        );
                        line.rotation.x = -Math.PI / 2;
                        line.rotation.z = Math.PI / 2;
                        line.position.set(i, 0.02, z);  // Slightly raised above road
                        scene.add(line);
                    }
                }

                // Add sidewalks with improved appearance
                const sidewalkMaterial = new THREE.MeshStandardMaterial({
                    color: 0xE0E0E0,  // Light concrete color
                    roughness: 0.9,
                    metalness: 0.1,
                    envMapIntensity: 0.5
                });

                // Add sidewalks for horizontal roads
                for (let i = -80; i <= 80; i += roadSpacing) {
                    [-roadWidth/2 - 0.3, roadWidth/2 + 0.3].forEach(offset => {
                        const sidewalk = new THREE.Mesh(
                            new THREE.BoxGeometry(200, 0.12, 0.6),
                            sidewalkMaterial
                        );
                        sidewalk.position.set(0, 0.06, i + offset);  // Adjusted height
                        scene.add(sidewalk);
                    });
                }

                // Add sidewalks for vertical roads
                for (let i = -80; i <= 80; i += roadSpacing) {
                    [-roadWidth/2 - 0.3, roadWidth/2 + 0.3].forEach(offset => {
                        const sidewalk = new THREE.Mesh(
                            new THREE.BoxGeometry(0.6, 0.12, 200),
                            sidewalkMaterial
                        );
                        sidewalk.position.set(i + offset, 0.06, 0);  // Adjusted height
                        scene.add(sidewalk);
                    });
                }

                // Add some random grass patches
                const grassPatchGeometry = new THREE.CircleGeometry(1, 6);
                const darkGrassMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2E4A0A,  // Darker grass
                    roughness: 0.9,
                    metalness: 0.1
                });

                for (let i = 0; i < 50; i++) {
                    const grassPatch = new THREE.Mesh(grassPatchGeometry, darkGrassMaterial);
                    grassPatch.rotation.x = -Math.PI / 2;
                    
                    // Position away from roads
                    let x, z;
                    do {
                        x = Math.random() * 90 - 45;
                        z = Math.random() * 90 - 45;
                    } while (Math.abs(x) < roadWidth/2 + 1 || Math.abs(z) < roadWidth/2 + 1);
                    
                    grassPatch.position.set(x, 0.01, z);
                    grassPatch.scale.set(
                        Math.random() * 2 + 1,
                        Math.random() * 2 + 1,
                        1
                    );
                    grassPatch.rotation.z = Math.random() * Math.PI;
                    scene.add(grassPatch);
                }

                console.log('Ground and roads created');

                // Create player
                createPlayer();
                console.log('Player created');

                // Create initial objects
                FOOD_TYPES.forEach(foodType => {
                    createRestaurant(foodType);
                    // Add extra restaurants with lower probability (33% chance instead of 50%)
                    if (Math.random() < 0.33) {
                        createRestaurant(foodType);
                    }
                });
                
                for(let i = 0; i < 20; i++) { // Increased from 12 to 20 houses
                    createHouse();
                }
                console.log('Game objects created');

                // Add grid helper
                const gridHelper = new THREE.GridHelper(100, 100, 0x666666, 0x444444);
                scene.add(gridHelper);
                console.log('Grid helper added');

                // Create UI elements
                createUIElements();
                console.log('UI elements created');

                // Create initial obstacles
                createInitialObstacles();
                console.log('Obstacles created');

                // Start game loop
                console.log('Starting animation loop...');
                animate();

                // Add event listeners
                window.addEventListener('resize', onWindowResize, false);
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);

                // Start game timer
                setInterval(updateTimer, 1000);
                
                console.log('Initialization complete');

                // Select initial random restaurant for first pickup
                highlightNextRestaurant();
                showMessage('Find the restaurant with the blue arrow!', '#00BFFF');

                // Create boundary walls
                createBoundaryWalls();
                console.log('Boundary walls created');
            } catch (error) {
                console.error('Error during initialization:', error);
                document.body.innerHTML += '<div style="color: white; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: Arial;">An error occurred while initializing the game. Please refresh the page.</div>';
            }
        }

        // Create UI elements
        function createUIElements() {
            // Add high score button
            const highScoreBtn = document.createElement('button');
            highScoreBtn.innerHTML = 'üèÜ High Scores';
            highScoreBtn.style.position = 'fixed';
            highScoreBtn.style.top = '20px';
            highScoreBtn.style.right = isMobile() ? '20px' : '120px';
            highScoreBtn.style.padding = '8px 16px';
            highScoreBtn.style.background = '#E23744';
            highScoreBtn.style.color = 'white';
            highScoreBtn.style.border = 'none';
            highScoreBtn.style.borderRadius = '5px';
            highScoreBtn.style.cursor = 'pointer';
            highScoreBtn.style.zIndex = '100';
            highScoreBtn.onclick = showHighScores;
            document.body.appendChild(highScoreBtn);

            // Add social sharing button
            const shareButton = document.createElement('button');
            shareButton.innerHTML = 'üê¶ Share Score';
            shareButton.style.position = 'fixed';
            shareButton.style.top = isMobile() ? '70px' : '20px';
            shareButton.style.right = isMobile() ? '20px' : '250px';
            shareButton.style.padding = '8px 16px';
            shareButton.style.background = '#1DA1F2';
            shareButton.style.color = 'white';
            shareButton.style.border = 'none';
            shareButton.style.borderRadius = '5px';
            shareButton.style.cursor = 'pointer';
            shareButton.style.zIndex = '100';
            shareButton.onclick = shareScore;
            document.body.appendChild(shareButton);

            // Add touch event handlers for mobile
            if (isMobile()) {
                // Prevent default touch behaviors
                document.addEventListener('touchmove', function(e) {
                    e.preventDefault();
                }, { passive: false });

                document.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                }, { passive: false });

                // Add orientation change handler
                window.addEventListener('orientationchange', function() {
                    setTimeout(onWindowResize, 100);
                });
            }
        }

        // Create initial obstacles
        function createInitialObstacles() {
            // Create initial vehicles - reduced from 3 to 2
            for (let i = 0; i < 2; i++) {
                createVehicle();
            }

            // Create initial obstacles - reduced from 5 to 3
            for (let i = 0; i < 3; i++) {
                const types = ['auto', 'cow', 'vendor', 'vehicle'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                let obstacle;
                switch(type) {
                    case 'auto':
                        obstacle = createAutoRickshaw();
                        break;
                    case 'cow':
                        obstacle = createCow();
                        break;
                    case 'vendor':
                        obstacle = createStreetVendor();
                        break;
                    default:
                        createVehicle();
                        continue;
                }

                // Set random position and direction
                const isHorizontal = Math.random() < 0.5;
                const position = (Math.random() - 0.5) * 20; // Reduced from 40 to 20
                const direction = Math.random() < 0.5 ? 1 : -1;

                if (isHorizontal) {
                    obstacle.position.set(-15 * direction, 0.6, position); // Reduced from -25 to -15
                    obstacle.rotation.y = direction > 0 ? -Math.PI / 2 : Math.PI / 2;
                } else {
                    obstacle.position.set(position, 0.6, -15 * direction); // Reduced from -25 to -15
                    obstacle.rotation.y = direction > 0 ? Math.PI : 0;
                }

                // Add movement properties
                obstacle.speed = 0.1 + Math.random() * 0.1;
                obstacle.direction = direction;
                obstacle.isHorizontal = isHorizontal;
                
                // Add erratic movement for auto-rickshaws
                if (obstacle.userData.type === 'auto') {
                    obstacle.zigzagPhase = 0;
                    obstacle.zigzagSpeed = 0.05;
                }

                scene.add(obstacle);
                specialObstacles.push(obstacle);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        const keys = { left: false, right: false, up: false, down: false };

        function onKeyDown(event) {
            switch(event.key) {
                case 'ArrowLeft': keys.left = true; break;
                case 'ArrowRight': keys.right = true; break;
                case 'ArrowUp': keys.up = true; break;
                case 'ArrowDown': keys.down = true; break;
            }
        }

        function onKeyUp(event) {
            switch(event.key) {
                case 'ArrowLeft': keys.left = false; break;
                case 'ArrowRight': keys.right = false; break;
                case 'ArrowUp': keys.up = false; break;
                case 'ArrowDown': keys.down = false; break;
            }
        }

        function updatePlayer() {
            const speed = 0.2;
            let moved = false;
            const newPosition = player.position.clone();
            const cityBoundary = 20;

            // Only process keyboard controls if not using joystick on mobile
            if (!isMobile()) {
                if (keys.left) {
                    newPosition.x -= speed;
                    player.rotation.y = Math.PI / 2;
                    moved = true;
                }
                if (keys.right) {
                    newPosition.x += speed;
                    player.rotation.y = -Math.PI / 2;
                    moved = true;
                }
                if (keys.up) {
                    newPosition.z -= speed;
                    player.rotation.y = 0;
                    moved = true;
                }
                if (keys.down) {
                    newPosition.z += speed;
                    player.rotation.y = Math.PI;
                    moved = true;
                }

                // Diagonal movement
                if (keys.up && keys.right) player.rotation.y = -Math.PI / 4;
                if (keys.up && keys.left) player.rotation.y = Math.PI / 4;
                if (keys.down && keys.right) player.rotation.y = -3 * Math.PI / 4;
                if (keys.down && keys.left) player.rotation.y = 3 * Math.PI / 4;

                // Check boundary collision
                if (Math.abs(newPosition.x) < cityBoundary && Math.abs(newPosition.z) < cityBoundary) {
                    player.position.copy(newPosition);
                }

                // Update camera position to follow player (chase view only)
                if (moved) {
                    camera.position.x = player.position.x;
                    camera.position.z = player.position.z + 8;
                    camera.position.y = 18;
                    camera.lookAt(player.position.x, 0, player.position.z - 2);
                }
            }
        }

        function checkCollisions() {
            const playerPos = player.position;

            // Check restaurants for pickup
            if (!currentDelivery) {
                restaurants.forEach(restaurant => {
                    if (playerPos.distanceTo(restaurant.position) < 2) {
                        // Only allow pickup from the highlighted restaurant
                        if (restaurant === nextRestaurant) {
                            // Select random house as delivery target
                            targetHouse = houses[Math.floor(Math.random() * houses.length)];
                            highlightTargetHouse(targetHouse);

                            currentDelivery = {
                                foodType: restaurant.foodType,
                                restaurant: restaurant.foodType.restaurant,
                                targetHouse: targetHouse
                            };
                            
                            const isQuickCommerce = restaurant.foodType.name === "Quick Commerce";
                            showDeliveryType(`Picked up: ${restaurant.foodType.name} from ${isQuickCommerce ? 'Quick Commerce Store' : restaurant.foodType.restaurant}`, true);
                            showMessage('Deliver to the house with the green arrow!', '#00FF00');
                            
                            // Add delivery bag visual effect
                            const deliveryBag = player.children.find(child => child.isDeliveryBag);
                            if (deliveryBag) {
                                deliveryBag.material.color.setHex(restaurant.foodType.color);
                            }

                            // Remove restaurant highlight
                            if (restaurant.arrow) {
                                scene.remove(restaurant.arrow);
                                restaurant.arrow = null;
                            }
                            if (restaurant.outline) {
                                scene.remove(restaurant.outline);
                                restaurant.outline = null;
                            }
                        }
                        // Removed "Wrong restaurant" message
                    }
                });
            }

            // Check houses for delivery
            if (currentDelivery) {
                if (playerPos.distanceTo(currentDelivery.targetHouse.position) < 2) {
                    // Calculate bonus points based on consecutive deliveries
                    const basePoints = currentDelivery.foodType.points;
                    const bonusMultiplier = Math.min(3, 1 + (consecutiveDeliveries * 0.5));
                    const totalPoints = Math.floor(basePoints * bonusMultiplier);
                    
                    // Create delivery effect
                    const particles = new THREE.Group();
                    for (let i = 0; i < 10; i++) {
                        const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                        const particleMaterial = new THREE.MeshBasicMaterial({
                            color: currentDelivery.foodType.color,
                            transparent: true,
                            opacity: 0.8
                        });
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        particle.position.copy(currentDelivery.targetHouse.position);
                        particle.velocity = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.2,
                            Math.random() * 0.2,
                            (Math.random() - 0.5) * 0.2
                        );
                        particles.add(particle);
                    }
                    scene.add(particles);

                    // Update score and show delivery message with bonus
                    consecutiveDeliveries++;
                    updateScore(totalPoints);
                    const bonusText = consecutiveDeliveries > 1 ? ` (${consecutiveDeliveries}x bonus!)` : '';
                    showDeliveryType(`Delivered ${currentDelivery.foodType.name} to customer${bonusText}`, false);

                    // Reset delivery bag color
                    const deliveryBag = player.children.find(child => child.isDeliveryBag);
                    if (deliveryBag) {
                        deliveryBag.material.color.setHex(COLORS.PRIMARY);
                    }

                    // Remove target house highlight
                    highlightTargetHouse(null);

                    // Animate particles
                    const animateParticles = () => {
                        particles.children.forEach(particle => {
                            particle.position.add(particle.velocity);
                            particle.material.opacity -= 0.02;
                        });
                        if (particles.children[0].material.opacity > 0) {
                            requestAnimationFrame(animateParticles);
                        } else {
                            scene.remove(particles);
                        }
                    };
                    animateParticles();

                    // Select new random restaurant for next pickup
                    highlightNextRestaurant();
                    const nextIsQuickCommerce = nextRestaurant && nextRestaurant.foodType.name === "Quick Commerce";
                    showMessage(`New order! Find the ${nextIsQuickCommerce ? 'Quick Commerce Store' : 'restaurant'} with the blue arrow!`, '#00BFFF');

                    currentDelivery = null;
                    targetHouse = null;
                } else if (playerPos.distanceTo(houses.find(h => h !== currentDelivery.targetHouse).position) < 2) {
                    // Wrong house penalty
                    consecutiveDeliveries = 0;
                    showDeliveryType("Wrong house! Find the one with the white arrow!", false);
                }
            }

            // Check power-ups
            powerUps.forEach((powerUp, index) => {
                if (playerPos.distanceTo(powerUp.position) < 1.5) {
                    scene.remove(powerUp);
                    powerUps.splice(index, 1);
                    applyPowerUp();
                    setTimeout(createPowerUp, 10000);
                }
            });

            checkAchievements();
        }

        function updateScore(points) {
            gameState.score += points;
            document.getElementById('score').textContent = `Score: ${gameState.score}`;
        }

        function updateTimer() {
            if (gameState.timeLeft > 0) {
                gameState.timeLeft--;
                document.getElementById('timer').textContent = `Time: ${gameState.timeLeft}`;
                if (gameState.timeLeft === 0) {
                    endGame();
                }
            }
        }

        function applyPowerUp() {
            gameState.pointMultiplier = 2;
            setTimeout(() => { gameState.pointMultiplier = 1; }, 5000);
        }

        // Add game counter
        let totalGamesPlayed = parseInt(localStorage.getItem('totalGamesPlayed')) || 0;
        let globalGamesPlayed = 0;

        // Function to get global games count
        async function getGlobalGamesCount() {
            try {
                const response = await fetch('https://api.countapi.xyz/get/indian-delivery-madness/total-games');
                const data = await response.json();
                globalGamesPlayed = data.value || 0;
                updateGlobalCountDisplay();
                return data.value || 0;
            } catch (error) {
                console.error('Error fetching global count:', error);
                return 0;
            }
        }

        // Function to increment global games count
        async function incrementGlobalGamesCount() {
            try {
                const response = await fetch('https://api.countapi.xyz/hit/indian-delivery-madness/total-games');
                const data = await response.json();
                globalGamesPlayed = data.value;
                updateGlobalCountDisplay();
                return data.value;
            } catch (error) {
                console.error('Error incrementing global count:', error);
                return globalGamesPlayed;
            }
        }

        // Function to update all global count displays
        function updateGlobalCountDisplay() {
            const elements = document.querySelectorAll('.global-games-count');
            elements.forEach(element => {
                element.textContent = globalGamesPlayed;
            });
        }

        // Initialize global counter when page loads
        getGlobalGamesCount();

        function endGame() {
            // Update personal counter
            totalGamesPlayed++;
            localStorage.setItem('totalGamesPlayed', totalGamesPlayed);
            
            // Update global counter
            incrementGlobalGamesCount();
            
            saveHighScore(gameState.score);
            
            const endScreen = document.createElement('div');
            endScreen.style.position = 'fixed';
            endScreen.style.top = '50%';
            endScreen.style.left = '50%';
            endScreen.style.transform = 'translate(-50%, -50%)';
            endScreen.style.color = 'white';
            endScreen.style.fontSize = isMobile() ? '24px' : '32px';
            endScreen.style.fontFamily = 'Arial';
            endScreen.style.textAlign = 'center';
            endScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            endScreen.style.padding = '30px';
            endScreen.style.borderRadius = '15px';
            endScreen.style.zIndex = '1000';
            endScreen.style.width = isMobile() ? '90%' : 'auto';
            endScreen.style.maxWidth = '400px';

            let content = `<h1 style="color: #E23744">Game Over!</h1>`;
            content += `<p>Final Score: ${gameState.score}</p>`;
            if (highScores.length === 0 || gameState.score > highScores[0].score) {
                content += '<p style="color: #FFD700">New High Score! üèÜ</p>';
            }
            
            // Add game statistics with both personal and global counts
            content += `
                <div style="
                    margin: 15px 0;
                    padding: 15px;
                    background: rgba(255,255,255,0.1);
                    border-radius: 8px;
                    font-size: ${isMobile() ? '16px' : '20px'};
                    display: flex;
                    justify-content: space-around;
                    align-items: center;
                ">
                    <div>
                        <div style="color: #FFD700;">üéÆ Your Games</div>
                        <div>${totalGamesPlayed}</div>
                    </div>
                    <div>
                        <div style="color: #FFD700;">üåé All Games</div>
                        <div class="global-games-count">${globalGamesPlayed}</div>
                    </div>
                </div>
            `;
            
            content += `
                <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                    <button id="viewScores" style="
                        margin: 10px;
                        padding: 8px 16px;
                        background: #E23744;
                        border: none;
                        color: white;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: ${isMobile() ? '14px' : '16px'};
                    ">View High Scores</button>
                    <button id="playAgain" style="
                        margin: 10px;
                        padding: 8px 16px;
                        background: #32CD32;
                        border: none;
                        color: white;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: ${isMobile() ? '14px' : '16px'};
                    ">Play Again</button>
                </div>`;
            
            endScreen.innerHTML = content;
            document.body.appendChild(endScreen);

            document.getElementById('viewScores').onclick = () => {
                showHighScores();
            };

            document.getElementById('playAgain').onclick = () => {
                location.reload();
            };
        }

        function showDeliveryType(name, isPickup) {
            // Use the chat box for delivery notifications with appropriate colors
            if (isPickup) {
                showMessage(name, '#32CD32');  // Green for pickup
            } else {
                showMessage(name, '#FFD700');  // Gold for delivery
            }
        }

        function createPlayer() {
            // Create a group for the bike and rider
            player = new THREE.Group();

            // Motorcycle frame - more detailed
            const bikeGroup = new THREE.Group();
            
            // Main frame - thicker and more defined
            const mainFrameGeometry = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 12);
            const bikeMaterial = new THREE.MeshStandardMaterial({ 
                color: COLORS.PRIMARY,
                metalness: 0.8,
                roughness: 0.2
            });
            const mainFrame = new THREE.Mesh(mainFrameGeometry, bikeMaterial);
            mainFrame.rotation.z = Math.PI / 4;
            bikeGroup.add(mainFrame);

            // Secondary frame tubes - more realistic structure
            const secondaryFrameGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.8, 12);
            const secondaryFrame = new THREE.Mesh(secondaryFrameGeometry, bikeMaterial);
            secondaryFrame.rotation.z = -Math.PI / 6;
            secondaryFrame.position.set(0.2, 0.2, 0);
            bikeGroup.add(secondaryFrame);

            // Add additional frame support
            const supportFrameGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 8);
            const supportFrame = new THREE.Mesh(supportFrameGeometry, bikeMaterial);
            supportFrame.rotation.z = Math.PI / 3;
            supportFrame.position.set(-0.1, 0.3, 0);
            bikeGroup.add(supportFrame);

            // Engine block - more detailed
            const engineGeometry = new THREE.Group();
            // Main engine block
            const engineBlockGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.3);
            const engineMaterial = new THREE.MeshStandardMaterial({
                color: 0x2A2A2A,
                metalness: 0.9,
                roughness: 0.3
            });
            const engineBlock = new THREE.Mesh(engineBlockGeometry, engineMaterial);
            engineGeometry.add(engineBlock);

            // Engine details (cylinders)
            const cylinderGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.3, 8);
            const cylinderMaterial = new THREE.MeshStandardMaterial({
                color: 0x3A3A3A,
                metalness: 0.8,
                roughness: 0.4
            });
            [-0.1, 0.1].forEach(x => {
                const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                cylinder.rotation.x = Math.PI / 2;
                cylinder.position.set(x, 0, 0.15);
                engineGeometry.add(cylinder);
            });
            engineGeometry.position.set(0, 0, 0);
            bikeGroup.add(engineGeometry);

            // Exhaust pipe - more detailed
            const exhaustGroup = new THREE.Group();
            const exhaustGeometry = new THREE.CylinderGeometry(0.04, 0.05, 0.8, 8);
            const exhaustMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                metalness: 0.9,
                roughness: 0.3
            });
            const exhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            exhaust.rotation.z = Math.PI / 6;
            exhaust.position.set(-0.2, -0.1, 0.1);
            exhaustGroup.add(exhaust);

            // Add exhaust tip
            const exhaustTipGeometry = new THREE.CylinderGeometry(0.06, 0.04, 0.1, 8);
            const exhaustTip = new THREE.Mesh(exhaustTipGeometry, exhaustMaterial);
            exhaustTip.position.set(-0.4, -0.2, 0.1);
            exhaustTip.rotation.z = Math.PI / 6;
            exhaustGroup.add(exhaustTip);
            bikeGroup.add(exhaustGroup);

            // Enhanced handlebars
            const handlebarGroup = new THREE.Group();
            const handlebarStemGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
            const handlebarStem = new THREE.Mesh(handlebarStemGeometry, bikeMaterial);
            handlebarStem.rotation.z = -Math.PI / 6;
            handlebarStem.position.set(0.4, 0.4, 0);
            handlebarGroup.add(handlebarStem);

            // Curved handlebars
            const handlebarGeometry = new THREE.TorusGeometry(0.2, 0.03, 8, 16, Math.PI);
            const handlebar = new THREE.Mesh(handlebarGeometry, bikeMaterial);
            handlebar.position.set(0.5, 0.6, 0);
            handlebar.rotation.x = Math.PI / 2;
            handlebarGroup.add(handlebar);

            // Add handlebar grips with better detail
            const gripGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.12, 8);
            const gripMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.9
            });
            [-0.2, 0.2].forEach(z => {
                const grip = new THREE.Mesh(gripGeometry, gripMaterial);
                grip.rotation.x = Math.PI / 2;
                grip.position.set(0.5, 0.6, z);
                handlebarGroup.add(grip);
            });
            bikeGroup.add(handlebarGroup);

            // Enhanced seat
            const seatGroup = new THREE.Group();
            const seatBaseGeometry = new THREE.BoxGeometry(0.4, 0.05, 0.3);
            const seatMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.9
            });
            const seatBase = new THREE.Mesh(seatBaseGeometry, seatMaterial);
            seatBase.position.set(-0.2, 0.5, 0);
            seatGroup.add(seatBase);

            // Add curved seat top
            const seatTopGeometry = new THREE.BoxGeometry(0.35, 0.08, 0.25);
            const seatTop = new THREE.Mesh(seatTopGeometry, seatMaterial);
            seatTop.position.set(-0.2, 0.55, 0);
            // Round the edges by scaling
            seatTop.scale.set(1, 0.8, 0.9);
            seatGroup.add(seatTop);
            bikeGroup.add(seatGroup);

            // Enhanced wheels with spokes
            const wheelGroup = new THREE.Group();
            
            // Improved tire geometry
            const tireGeometry = new THREE.TorusGeometry(0.3, 0.06, 16, 32);
            const tireMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                metalness: 0.1,
                roughness: 0.9
            });

            // Improved rim geometry
            const rimGeometry = new THREE.TorusGeometry(0.3, 0.02, 8, 32);
            const rimMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xCCCCCC,
                metalness: 0.9,
                roughness: 0.1
            });

            // More detailed spokes
            const spokeGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.58, 4);
            const spokeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xCCCCCC,
                metalness: 0.9,
                roughness: 0.1
            });

            // Create front and back wheels with more spokes
            [-0.5, 0.5].forEach(x => {
                const wheelComplete = new THREE.Group();
                
                // Add tire
                const tire = new THREE.Mesh(tireGeometry, tireMaterial);
                wheelComplete.add(tire);

                // Add rim
                const rim = new THREE.Mesh(rimGeometry, rimMaterial);
                wheelComplete.add(rim);

                // Add more spokes (12 instead of 8)
                for (let i = 0; i < 12; i++) {
                    const spoke = new THREE.Mesh(spokeGeometry, spokeMaterial);
                    spoke.rotation.z = (i * Math.PI) / 6;
                    wheelComplete.add(spoke);
                }

                wheelComplete.rotation.y = Math.PI / 2;
                wheelComplete.position.set(x, -0.2, 0);
                bikeGroup.add(wheelComplete);
            });

            // Add brake discs with better detail
            const brakeGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.02, 16);
            const brakeMaterial = new THREE.MeshStandardMaterial({
                color: 0xCCCCCC,
                metalness: 0.9,
                roughness: 0.1
            });

            [-0.45, 0.45].forEach(x => {
                const brake = new THREE.Mesh(brakeGeometry, brakeMaterial);
                brake.rotation.z = Math.PI / 2;
                brake.position.set(x, -0.2, 0);
                bikeGroup.add(brake);
            });

            // Enhanced headlight
            const headlightGroup = new THREE.Group();
            const headlightGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.05, 16);
            const headlightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.5
            });
            const headlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            headlight.rotation.z = Math.PI / 2;
            headlight.position.set(0.6, 0.3, 0);
            headlightGroup.add(headlight);

            // Add headlight casing
            const headlightCasingGeometry = new THREE.CylinderGeometry(0.09, 0.09, 0.04, 16);
            const headlightCasing = new THREE.Mesh(headlightCasingGeometry, bikeMaterial);
            headlightCasing.rotation.z = Math.PI / 2;
            headlightCasing.position.set(0.62, 0.3, 0);
            headlightGroup.add(headlightCasing);
            bikeGroup.add(headlightGroup);

            // Enhanced tail light
            const tailLightGroup = new THREE.Group();
            const tailLightGeometry = new THREE.BoxGeometry(0.12, 0.05, 0.2);
            const tailLightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0xFF0000,
                emissiveIntensity: 0.5
            });
            const tailLight = new THREE.Mesh(tailLightGeometry, tailLightMaterial);
            tailLight.position.set(-0.4, 0.3, 0);
            tailLightGroup.add(tailLight);

            // Add tail light casing
            const tailLightCasingGeometry = new THREE.BoxGeometry(0.14, 0.07, 0.22);
            const tailLightCasing = new THREE.Mesh(tailLightCasingGeometry, bikeMaterial);
            tailLightCasing.position.set(-0.41, 0.3, 0);
            tailLightGroup.add(tailLightCasing);
            bikeGroup.add(tailLightGroup);

            // Scale and add the complete bike to player group
            bikeGroup.scale.set(1, 1, 0.8);
            player.add(bikeGroup);

            // Create enhanced rider
            const riderGroup = new THREE.Group();

            // Body with better proportions
            const torsoGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.4, 8);
            const riderMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2244AA, // Blue jacket
                roughness: 0.8
            });
            const torso = new THREE.Mesh(torsoGeometry, riderMaterial);
            torso.position.y = 0.5;
            torso.rotation.x = Math.PI / 6; // Lean forward
            riderGroup.add(torso);

            // Add spherical caps to torso for smoother look
            const topSphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 8, 8),
                riderMaterial
            );
            topSphere.position.y = 0.7;
            topSphere.rotation.x = Math.PI / 6;
            riderGroup.add(topSphere);

            const bottomSphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 8, 8),
                riderMaterial
            );
            bottomSphere.position.y = 0.3;
            riderGroup.add(bottomSphere);

            // Head with Zomato red helmet
            const helmetGroup = new THREE.Group();
            
            // Base helmet in Zomato red
            const helmetGeometry = new THREE.SphereGeometry(0.15, 12, 12);
            const helmetMaterial = new THREE.MeshStandardMaterial({ 
                color: COLORS.PRIMARY, // Zomato red
                metalness: 0.8,
                roughness: 0.2
            });
            const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
            helmet.scale.set(1, 0.8, 1);
            helmetGroup.add(helmet);

            // Add helmet visor
            const visorGeometry = new THREE.SphereGeometry(0.12, 12, 12, 0, Math.PI * 2, 0, Math.PI / 3);
            const visorMaterial = new THREE.MeshStandardMaterial({
                color: 0x111111,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.7
            });
            const visor = new THREE.Mesh(visorGeometry, visorMaterial);
            visor.position.z = 0.04;
            visor.rotation.x = -0.3;
            helmetGroup.add(visor);

            // Add Zomato logo on helmet sides
            const logoGeometry = new THREE.PlaneGeometry(0.08, 0.08);
            const logoMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF,
                side: THREE.DoubleSide
            });
            [-1, 1].forEach(x => {
                const logo = new THREE.Mesh(logoGeometry, logoMaterial);
                logo.position.set(x * 0.15, 0, 0);
                logo.rotation.y = x * Math.PI / 2;
                helmetGroup.add(logo);
            });

            helmetGroup.position.set(0, 0.92, -0.1);
            riderGroup.add(helmetGroup);

            // Enhanced arms with better joints
            const armGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8);
            const armMaterial = riderMaterial;
            
            [-0.2, 0.2].forEach(x => {
                const armGroup = new THREE.Group();
                
                // Upper arm
                const upperArm = new THREE.Mesh(armGeometry, armMaterial);
                upperArm.position.set(0, -0.15, 0);
                armGroup.add(upperArm);

                // Elbow joint
                const elbowJoint = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 8, 8),
                    armMaterial
                );
                armGroup.add(elbowJoint);

                // Forearm
                const forearm = new THREE.Mesh(armGeometry, armMaterial);
                forearm.position.set(0, 0.15, 0);
                armGroup.add(forearm);

                armGroup.position.set(x, 0.6, 0);
                armGroup.rotation.z = x > 0 ? -Math.PI / 4 : Math.PI / 4;
                riderGroup.add(armGroup);
            });

            // Enhanced legs with better joints
            const legGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.4, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x1A237E }); // Dark blue pants
            
            [-0.1, 0.1].forEach(x => {
                const legGroup = new THREE.Group();
                
                // Upper leg
                const upperLeg = new THREE.Mesh(legGeometry, legMaterial);
                upperLeg.position.set(0, -0.2, 0);
                legGroup.add(upperLeg);

                // Knee joint
                const kneeJoint = new THREE.Mesh(
                    new THREE.SphereGeometry(0.07, 8, 8),
                    legMaterial
                );
                legGroup.add(kneeJoint);

                // Lower leg
                const lowerLeg = new THREE.Mesh(legGeometry, legMaterial);
                lowerLeg.position.set(0, 0.2, 0);
                legGroup.add(lowerLeg);

                legGroup.position.set(x, 0.2, 0);
                legGroup.rotation.z = x > 0 ? Math.PI / 6 : -Math.PI / 6;
                riderGroup.add(legGroup);
            });

            // Enhanced delivery bag
            const bagGroup = new THREE.Group();
            
            // Main bag with Zomato branding
            const bagGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.3);
            const bagMaterial = new THREE.MeshStandardMaterial({ 
                color: COLORS.PRIMARY,
                metalness: 0.1,
                roughness: 0.8
            });
            const bag = new THREE.Mesh(bagGeometry, bagMaterial);
            bagGroup.add(bag);

            // Add bag straps
            const strapGeometry = new THREE.BoxGeometry(0.05, 0.4, 0.05);
            const strapMaterial = bagMaterial;
            
            [-0.15, 0.15].forEach(x => {
                const strap = new THREE.Mesh(strapGeometry, strapMaterial);
                strap.position.set(x, 0.2, 0);
                bagGroup.add(strap);
            });

            // Add Zomato logo to bag
            const bagLogoGeometry = new THREE.PlaneGeometry(0.2, 0.2);
            const bagLogoMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.9
            });
            const bagLogo = new THREE.Mesh(bagLogoGeometry, bagLogoMaterial);
            bagLogo.position.set(0, 0, 0.151);
            bagGroup.add(bagLogo);

            bagGroup.position.set(0, 0.5, -0.3);
            bagGroup.isDeliveryBag = true;
            riderGroup.add(bagGroup);

            // Add rider to player group
            player.add(riderGroup);

            // Add player to scene
            scene.add(player);
            player.position.y = 0.5;
        }

        function createVehicle() {
            const vehicleType = VEHICLE_TYPES[Math.floor(Math.random() * VEHICLE_TYPES.length)];
            const vehicle = new THREE.Group();
            
            // Vehicle body
            const bodyGeometry = new THREE.BoxGeometry(vehicleType.width, 1, vehicleType.length);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: vehicleType.color,
                metalness: 0.6,
                roughness: 0.4
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            vehicle.add(body);

            // Add wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            
            [-1, 1].forEach(x => {
                [-1, 1].forEach(z => {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(
                        x * (vehicleType.width / 2 + 0.1),
                        -0.3,
                        z * (vehicleType.length / 3)
                    );
                    vehicle.add(wheel);
                });
            });

            // Set random position and direction
            const isHorizontal = Math.random() < 0.5;
            const position = (Math.random() - 0.5) * 20; // Reduced from 40 to 20
            const direction = Math.random() < 0.5 ? 1 : -1;

            if (isHorizontal) {
                vehicle.position.set(-15 * direction, 0.6, position); // Reduced from -25 to -15
                vehicle.rotation.y = direction > 0 ? -Math.PI / 2 : Math.PI / 2;
            } else {
                vehicle.position.set(position, 0.6, -15 * direction); // Reduced from -25 to -15
                vehicle.rotation.y = direction > 0 ? Math.PI : 0;
            }

            vehicle.speed = 0.1 + Math.random() * 0.1;
            vehicle.direction = direction;
            vehicle.isHorizontal = isHorizontal;
            vehicle.userData = { type: 'vehicle' };  // Add userData

            scene.add(vehicle);
            vehicles.push(vehicle);
            return vehicle;  // Return the vehicle object
        }

        function updateVehicles() {
            vehicles.forEach((vehicle, index) => {
                if (vehicle.isHorizontal) {
                    vehicle.position.x += vehicle.speed * vehicle.direction;
                    if (Math.abs(vehicle.position.x) > 25) {
                        scene.remove(vehicle);
                        vehicles.splice(index, 1);
                    }
                } else {
                    vehicle.position.z += vehicle.speed * vehicle.direction;
                    if (Math.abs(vehicle.position.z) > 25) {
                        scene.remove(vehicle);
                        vehicles.splice(index, 1);
                    }
                }

                // Check collision with player
                if (player.position.distanceTo(vehicle.position) < 1.5) {
                    handleCollision(vehicle);
                }
            });

            // Add new vehicles
            if (vehicles.length < 5 && Math.random() < 0.02) {
                createVehicle();
            }
        }

        // Handle different types of collisions
        function handleCollision(obstacle) {
            // If player is invulnerable, ignore collision
            if (gameState.isInvulnerable) {
                return;
            }

            if (!obstacle || !obstacle.userData) {
                console.warn('Invalid obstacle in handleCollision');
                return;
            }

            let penalty = 10;
            let message = '';

            try {
                switch(obstacle.userData.type) {
                    case 'auto':
                        penalty = 15;
                        message = 'Arre Bhai! Auto rickshaw collision! -15 points';
                        break;
                    case 'cow':
                        penalty = 20;
                        message = 'Jai Gau Mata! Be careful! -20 points';
                        break;
                    case 'vehicle':
                        penalty = 10;
                        message = 'Traffic jam ho gaya! -10 points';
                        break;
                    default:
                        message = 'Arey yaar! Collision! -10 points';
                }

                gameState.score = Math.max(0, gameState.score - penalty);
                document.getElementById('score').textContent = `Score: ${gameState.score}`;
                
                if (typeof showMessage === 'function') {
                    showMessage(message, '#FF4444');
                }
                showCollisionEffect();
                consecutiveDeliveries = 0;

                // Add invulnerability for 1.5 seconds
                gameState.isInvulnerable = true;
                setTimeout(() => {
                    gameState.isInvulnerable = false;
                }, 1500);

            } catch (error) {
                console.error('Error in handleCollision:', error);
            }
        }

        function updateDirectionArrow() {
            // Since we've removed the direction arrow functionality in favor of the new highlighting system,
            // this function is now empty
            return;
        }

        function animate() {
            try {
                requestAnimationFrame(animate);

                if (!scene || !camera || !renderer) {
                    console.warn('Scene, camera, or renderer not initialized');
                    return;
                }

                const time = Date.now() * 0.001; // Current time in seconds

                // Animate restaurant markers with enhanced effects
                if (nextRestaurant) {
                    if (nextRestaurant.arrow) {
                        // More pronounced floating motion
                        nextRestaurant.arrow.position.y = 3 + Math.sin(time * 3 + nextRestaurant.arrow.userData.animationOffset) * 0.4;
                        // More dramatic opacity pulsing
                        nextRestaurant.arrow.material.opacity = 0.4 + Math.sin(time * 4 + nextRestaurant.arrow.userData.animationOffset) * 0.6;
                        // Add rotation for more visibility
                        nextRestaurant.arrow.rotation.y = Math.sin(time * 2) * 0.3;
                    }
                    if (nextRestaurant.outline) {
                        // Enhanced outline pulsing
                        nextRestaurant.outline.material.opacity = 0.2 + Math.sin(time * 3 + nextRestaurant.outline.userData.animationOffset) * 0.5;
                        // More dramatic scaling
                        const scale = 1.2 + Math.sin(time * 3 + nextRestaurant.outline.userData.animationOffset) * 0.2;
                        nextRestaurant.outline.scale.set(scale, scale, scale);
                    }
                }

                // Animate house markers with enhanced effects
                houses.forEach(house => {
                    if (house.arrow) {
                        // More pronounced floating motion
                        house.arrow.position.y = 3 + Math.sin(time * 3 + house.arrow.userData.animationOffset) * 0.4;
                        // More dramatic opacity pulsing
                        house.arrow.material.opacity = 0.4 + Math.sin(time * 4 + house.arrow.userData.animationOffset) * 0.6;
                        // Add rotation for more visibility
                        house.arrow.rotation.y = Math.sin(time * 2) * 0.3;
                    }
                    if (house.outline) {
                        // Enhanced outline pulsing
                        house.outline.material.opacity = 0.2 + Math.sin(time * 3 + house.outline.userData.animationOffset) * 0.5;
                        // More dramatic scaling
                        const scale = 1.2 + Math.sin(time * 3 + house.outline.userData.animationOffset) * 0.2;
                        house.outline.scale.set(scale, scale, scale);
                    }
                });

                if (gameState.timeLeft > 0) {
                    updatePlayer();
                    checkCollisions();
                    updateVehicles();
                    updateObstacles();
                }

                renderer.render(scene, camera);
            } catch (error) {
                console.error('Error in animation loop:', error);
            }
        }

        // Start the game with error handling
        window.onload = function() {
            try {
                console.log('Window loaded, showing username modal...');
                showUsernameModal();
            } catch (error) {
                console.error('Failed to start game:', error);
                document.body.innerHTML += '<div style="color: white; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: Arial;">Failed to start the game. Please refresh the page.</div>';
            }
        };

        // Add social sharing
        function shareScore() {
            const shareText = encodeURIComponent(
                `üèçÔ∏è ${playerUsername} scored ${gameState.score} points in Indian Delivery Madness 3D!\n` +
                `Completed ${consecutiveDeliveries} deliveries in a row!\n` +
                `Can you beat their score? üéÆ\n` +
                `Play now: [game_url]`
            );
            window.open(`https://twitter.com/intent/tweet?text=${shareText}`);
        }

        // Add achievement system
        function addAchievement(name, description) {
            const achievement = { name, description, timestamp: new Date() };
            achievements.push(achievement);
            
            // Show achievement notification
            const notification = document.createElement('div');
            notification.style.position = 'fixed';
            notification.style.bottom = '20px';
            notification.style.right = '20px';
            notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            notification.style.color = '#FFD700';
            notification.style.padding = '15px';
            notification.style.borderRadius = '10px';
            notification.style.zIndex = '1000';
            notification.innerHTML = `
                <h3>üèÜ Achievement Unlocked!</h3>
                <p>${name}</p>
                <p>${description}</p>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.transition = 'opacity 1s';
                notification.style.opacity = '0';
                setTimeout(() => document.body.removeChild(notification), 1000);
            }, 3000);
        }

        // Add special obstacles
        function createAutoRickshaw() {
            const auto = new THREE.Group();
            
            // Auto body
            const bodyGeometry = new THREE.BoxGeometry(1.2, 1.2, 2);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: COLORS.AUTO,
                metalness: 0.3,
                roughness: 0.7
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            auto.add(body);

            // Auto roof
            const roofGeometry = new THREE.BoxGeometry(1.2, 0.4, 1);
            const roof = new THREE.Mesh(roofGeometry, bodyMaterial);
            roof.position.y = 0.8;
            roof.position.z = -0.5;
            auto.add(roof);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            [-1, 1].forEach(x => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(x * 0.6, -0.4, 0);
                auto.add(wheel);
            });

            const backWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            backWheel.rotation.z = Math.PI / 2;
            backWheel.position.set(0, -0.4, -0.8);
            auto.add(backWheel);

            auto.userData.type = 'auto';
            auto.userData.erratic = true;
            return auto;
        }

        function createCow() {
            const cow = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.BoxGeometry(1, 1.2, 2);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: COLORS.COW,
                metalness: 0.1,
                roughness: 0.9
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            cow.add(body);

            // Head
            const headGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.8);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.set(0, 0.3, 0.9);
            cow.add(head);

            // Legs
            const legGeometry = new THREE.BoxGeometry(0.2, 0.6, 0.2);
            [-1, 1].forEach(x => {
                [-1, 1].forEach(z => {
                    const leg = new THREE.Mesh(legGeometry, bodyMaterial);
                    leg.position.set(x * 0.4, -0.9, z * 0.8);
                    cow.add(leg);
                });
            });

            cow.userData.type = 'cow';
            cow.userData.peaceful = true;
            return cow;
        }

        function createStreetVendor() {
            const vendor = new THREE.Group();
            
            // Cart with more Indian street food cart style
            const cartGeometry = new THREE.BoxGeometry(1.5, 1, 2);
            const cartMaterial = new THREE.MeshStandardMaterial({ 
                color: COLORS.VENDOR,
                metalness: 0.3,
                roughness: 0.7
            });
            const cart = new THREE.Mesh(cartGeometry, cartMaterial);
            vendor.add(cart);

            // Add traditional Indian umbrella (more colorful)
            const umbrellaGeometry = new THREE.ConeGeometry(2, 0.5, 8);
            const umbrellaMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFF5733, // Bright orange
                metalness: 0.1,
                roughness: 0.9
            });
            const umbrella = new THREE.Mesh(umbrellaGeometry, umbrellaMaterial);
            umbrella.position.y = 2;
            vendor.add(umbrella);

            // Add decorative elements like food display
            const displayGeometry = new THREE.BoxGeometry(1.2, 0.2, 1.5);
            const displayMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFD700, // Gold for food display
                metalness: 0.4,
                roughness: 0.6
            });
            const display = new THREE.Mesh(displayGeometry, displayMaterial);
            display.position.set(0, 0.6, 0);
            vendor.add(display);

            // Add small food items on display
            for(let i = 0; i < 6; i++) {
                const foodGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const foodMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFF9933, // Saffron for food items
                    metalness: 0.2,
                    roughness: 0.8
                });
                const foodItem = new THREE.Mesh(foodGeometry, foodMaterial);
                foodItem.position.set(
                    (Math.random() - 0.5) * 0.8,
                    0.7,
                    (Math.random() - 0.5) * 1.2
                );
                vendor.add(foodItem);
            }

            vendor.userData.type = 'vendor';
            vendor.userData.bonus = true;
            return vendor;
        }

        // Create ground with Indian street texture
        function createGround() {
            const groundSize = 50;
            const textureResolution = 512;
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 128, 128);
            
            // Create custom ground texture with warmer, more natural tones
            const canvas = document.createElement('canvas');
            canvas.width = textureResolution;
            canvas.height = textureResolution;
            const ctx = canvas.getContext('2d');
            
            // Base color - warm earth tone
            ctx.fillStyle = '#A0522D';  // Sienna brown
            ctx.fillRect(0, 0, textureResolution, textureResolution);
            
            // Add richer texture variations
            for (let i = 0; i < 2000; i++) {
                const x = Math.random() * textureResolution;
                const y = Math.random() * textureResolution;
                const size = Math.random() * 3 + 1;
                const alpha = Math.random() * 0.15;
                
                // Use a mix of complementary earth tones
                const colors = [
                    '#8B4513',  // Saddle Brown
                    '#CD853F',  // Peru
                    '#DEB887',  // Burlywood
                    '#D2691E'   // Chocolate
                ];
                ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(12, 12);  // Increased repeat for more detailed texture
            
            const groundMaterial = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.8,
                metalness: 0.1,
                bumpMap: texture,
                bumpScale: 0.15,
                envMapIntensity: 0.5
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            
            return ground;
        }

        // Update vehicle creation to include new obstacles
        function createObstacle() {
            const types = ['auto', 'cow', 'vendor', 'vehicle'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            let obstacle;
            switch(type) {
                case 'auto':
                    obstacle = createAutoRickshaw();
                    break;
                case 'cow':
                    obstacle = createCow();
                    break;
                case 'vendor':
                    obstacle = createStreetVendor();
                    break;
                default:
                    obstacle = createVehicle();
                    break;
            }

            // Check if obstacle creation failed
            if (!obstacle) {
                console.error('Failed to create obstacle of type:', type);
                return null;
            }

            // Set random position and direction
            const isHorizontal = Math.random() < 0.5;
            const position = (Math.random() - 0.5) * 20; // Reduced from 40 to 20
            const direction = Math.random() < 0.5 ? 1 : -1;

            if (isHorizontal) {
                obstacle.position.set(-15 * direction, 0.6, position); // Reduced from -25 to -15
                obstacle.rotation.y = direction > 0 ? -Math.PI / 2 : Math.PI / 2;
            } else {
                obstacle.position.set(position, 0.6, -15 * direction); // Reduced from -25 to -15
                obstacle.rotation.y = direction > 0 ? Math.PI : 0;
            }

            // Add movement properties
            obstacle.speed = 0.1 + Math.random() * 0.1;
            obstacle.direction = direction;
            obstacle.isHorizontal = isHorizontal;
            
            // Add erratic movement for auto-rickshaws
            if (obstacle.userData.type === 'auto') {
                obstacle.zigzagPhase = 0;
                obstacle.zigzagSpeed = 0.05;
            }

            scene.add(obstacle);
            specialObstacles.push(obstacle);
            return obstacle;
        }

        // Update the update function to handle special obstacles
        function updateObstacles() {
            specialObstacles.forEach((obstacle, index) => {
                // Basic movement
                if (obstacle.isHorizontal) {
                    obstacle.position.x += obstacle.speed * obstacle.direction;
                    
                    // Zigzag movement for auto-rickshaws
                    if (obstacle.userData.type === 'auto') {
                        obstacle.position.z += Math.sin(obstacle.zigzagPhase) * obstacle.zigzagSpeed;
                        obstacle.zigzagPhase += 0.1;
                    }
                    
                    if (Math.abs(obstacle.position.x) > 25) {
                        scene.remove(obstacle);
                        specialObstacles.splice(index, 1);
                    }
                } else {
                    obstacle.position.z += obstacle.speed * obstacle.direction;
                    
                    // Zigzag movement for auto-rickshaws
                    if (obstacle.userData.type === 'auto') {
                        obstacle.position.x += Math.sin(obstacle.zigzagPhase) * obstacle.zigzagSpeed;
                        obstacle.zigzagPhase += 0.1;
                    }
                    
                    if (Math.abs(obstacle.position.z) > 25) {
                        scene.remove(obstacle);
                        specialObstacles.splice(index, 1);
                    }
                }

                // Random stops for cows
                if (obstacle.userData.type === 'cow' && Math.random() < 0.01) {
                    obstacle.speed = obstacle.speed === 0 ? 0.1 : 0;
                }

                // Check collision with player
                if (obstacle && obstacle.position && player.position.distanceTo(obstacle.position) < 1.5) {
                    if (obstacle.userData && obstacle.userData.bonus) {
                        handleBonus(obstacle);
                    } else if (obstacle.userData && obstacle.userData.type) {
                        handleCollision(obstacle);
                    }
                }
            });

            // Add new obstacles - reduced max obstacles from 8 to 4 and spawn rate from 0.02 to 0.01
            if (specialObstacles.length < 4 && Math.random() < 0.01) {
                createObstacle();
            }
        }

        // Handle different types of collisions
        function handleCollision(obstacle) {
            // If player is invulnerable, ignore collision
            if (gameState.isInvulnerable) {
                return;
            }

            if (!obstacle || !obstacle.userData) {
                console.warn('Invalid obstacle in handleCollision');
                return;
            }

            let penalty = 10;
            let message = '';

            try {
                switch(obstacle.userData.type) {
                    case 'auto':
                        penalty = 15;
                        message = 'Arre Bhai! Auto rickshaw collision! -15 points';
                        break;
                    case 'cow':
                        penalty = 20;
                        message = 'STRAY ANIMAL ! Be careful! -20 points';
                        break;
                    case 'vehicle':
                        penalty = 10;
                        message = 'Traffic jam ho gaya! -10 points';
                        break;
                    default:
                        message = 'Arey yaar! Collision! -10 points';
                }

                gameState.score = Math.max(0, gameState.score - penalty);
                document.getElementById('score').textContent = `Score: ${gameState.score}`;
                
                if (typeof showMessage === 'function') {
                    showMessage(message, '#FF4444');
                }
                showCollisionEffect();
                consecutiveDeliveries = 0;

                // Add invulnerability for 1.5 seconds
                gameState.isInvulnerable = true;
                setTimeout(() => {
                    gameState.isInvulnerable = false;
                }, 1500);

            } catch (error) {
                console.error('Error in handleCollision:', error);
            }
        }

        // Handle bonus points from vendors
        function handleBonus(obstacle) {
            // If player is invulnerable, ignore bonus collection
            if (gameState.isInvulnerable) {
                return;
            }

            const bonus = 25;
            gameState.score += bonus;
            document.getElementById('score').textContent = `Score: ${gameState.score}`;
            
            const bonusMessages = [
                'Masala Bonus! +25 points',
                'Chatpata Bonus! +25 points',
                'Desi Style! +25 points',
                'Ekdum Jhakaas! +25 points'
            ];
            
            showMessage(bonusMessages[Math.floor(Math.random() * bonusMessages.length)], '#4CAF50');
            showBonusEffect();

            // Add invulnerability for 1.5 seconds
            gameState.isInvulnerable = true;
            setTimeout(() => {
                gameState.isInvulnerable = false;
            }, 1500);
        }

        // Show message popup
        function showMessage(text, color) {
            const container = document.getElementById('message-queue');
            if (!container) return;

            const message = document.createElement('div');
            message.className = 'message';
            message.style.borderLeftColor = color;
            message.style.whiteSpace = 'normal';
            message.style.marginBottom = '8px';
            message.style.transform = 'translateX(-20px)';
            message.style.opacity = '0';
            
            // Add timestamp with a class for mobile hiding
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            message.innerHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span class="timestamp" style="font-size: 12px; opacity: 0.7;">${timestamp}</span>
                </div>
                <div style="line-height: 1.4;">${text}</div>
            `;
            
            container.appendChild(message);
            
            // Force reflow
            message.offsetHeight;
            
            message.style.transition = 'all 0.3s ease-out';
            message.style.opacity = '1';
            message.style.transform = 'translateX(0)';
            
            // Keep only last 3 messages on mobile, 5 on desktop
            const maxMessages = isMobile() ? 3 : 5;
            while (container.children.length > maxMessages) {
                container.firstChild.style.opacity = '0';
                container.firstChild.style.transform = 'translateX(-20px)';
                setTimeout(() => container.firstChild && container.removeChild(container.firstChild), 300);
            }
            
            // Remove message after 4 seconds on mobile, 5 seconds on desktop
            const displayTime = isMobile() ? 4000 : 5000;
            setTimeout(() => {
                if (message.parentNode === container) {
                    message.style.opacity = '0';
                    message.style.transform = 'translateX(-20px)';
                    setTimeout(() => message.remove(), 300);
                }
            }, displayTime);
        }

        // Show collision effect
        function showCollisionEffect() {
            const flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            flash.style.zIndex = '99';
            document.body.appendChild(flash);
            
            // Add invulnerability visual effect
            if (player) {
                const originalMaterials = [];
                player.traverse((child) => {
                    if (child.isMesh) {
                        originalMaterials.push({
                            mesh: child,
                            material: child.material.clone()
                        });
                        child.material.opacity = 0.5;
                        child.material.transparent = true;
                    }
                });

                // Restore original materials after invulnerability ends
                setTimeout(() => {
                    originalMaterials.forEach(({mesh, material}) => {
                        mesh.material = material;
                    });
                }, 1500);
            }
            
            setTimeout(() => {
                document.body.removeChild(flash);
            }, 300);
        }

        // Show bonus effect
        function showBonusEffect() {
            const flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.backgroundColor = 'rgba(76, 175, 80, 0.3)';
            flash.style.zIndex = '99';
            document.body.appendChild(flash);
            
            setTimeout(() => {
                document.body.removeChild(flash);
            }, 300);
        }

        // Achievement triggers
        function checkAchievements() {
            // Delivery achievements
            if (consecutiveDeliveries === 5) {
                addAchievement('Delivery Master', 'Complete 5 deliveries in a row!');
            }
            
            // Score achievements
            if (gameState.score >= 1000) {
                addAchievement('Score Champion', 'Reach 1000 points!');
            }
        }

        // Update checkCollisions to include achievement checks
        const originalCheckCollisions = checkCollisions;
        checkCollisions = function() {
            originalCheckCollisions();
            checkAchievements();
        };

        // Add new function to highlight next restaurant
        function highlightNextRestaurant(restaurant) {
            // Reset all restaurants
            restaurants.forEach(r => {
                if (r.outline) {
                    scene.remove(r.outline);
                    r.outline = null;
                }
                if (r.arrow) {
                    scene.remove(r.arrow);
                    r.arrow = null;
                }
            });

            // If no specific restaurant is provided, randomly select one
            if (!restaurant) {
                // 50% chance to pick from quick commerce, 50% from regular restaurants
                const isQuickCommerce = Math.random() < 0.5;
                const availableRestaurants = restaurants.filter(r => 
                    isQuickCommerce ? r.foodType.name === "Quick Commerce" : r.foodType.name !== "Quick Commerce"
                );
                
                // If no restaurants of the chosen type are available, pick from any restaurant
                restaurant = availableRestaurants.length > 0 ? 
                    availableRestaurants[Math.floor(Math.random() * availableRestaurants.length)] :
                    restaurants[Math.floor(Math.random() * restaurants.length)];
            }

            if (restaurant) {
                // Add enhanced blue arrow above restaurant
                const arrowGeometry = new THREE.ConeGeometry(0.5, 1.0, 6); // Larger arrow
                const arrowMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00FFFF,  // Brighter blue
                    metalness: 0.5,
                    roughness: 0.5,
                    transparent: true,
                    opacity: 1,
                    emissive: 0x0088FF,
                    emissiveIntensity: 1
                });
                const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                arrow.position.copy(restaurant.position);
                arrow.position.y = 3.5;  // Slightly higher
                arrow.rotation.x = Math.PI;
                scene.add(arrow);
                restaurant.arrow = arrow;

                // Add enhanced outline effect
                const outlineGeometry = new THREE.BoxGeometry(2.4, 2.4, 2.4);
                const outlineMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00FFFF,  // Brighter blue
                    side: THREE.BackSide,
                    transparent: true,
                    opacity: 0.7
                });
                const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
                outline.position.copy(restaurant.position);
                outline.scale.set(1.3, 1.3, 1.3);  // Larger initial scale
                scene.add(outline);
                restaurant.outline = outline;

                // Add animation properties
                arrow.userData.animationOffset = Math.random() * Math.PI * 2;
                outline.userData.animationOffset = Math.random() * Math.PI * 2;
            }
            nextRestaurant = restaurant;
        }

        // Add message queue system variables
       
        function createBoundaryWalls() {
            const wallHeight = 4;
            const wallThickness = 1.5;
            const citySize = 44;  // Increased from 35 to 44 (25% larger)
            const groundSize = 50;  // Match the ground plane size
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0xF5F5F5,
                metalness: 0.2,
                roughness: 0.8,
                transparent: true,
                opacity: 0.8
            });

            // Create four walls
            const walls = [];
            
            // North wall
            const northWall = new THREE.Mesh(
                new THREE.BoxGeometry(groundSize + wallThickness, wallHeight, wallThickness),
                wallMaterial
            );
            northWall.position.set(0, wallHeight/2, -citySize/2);
            scene.add(northWall);
            walls.push(northWall);

            // South wall
            const southWall = new THREE.Mesh(
                new THREE.BoxGeometry(groundSize + wallThickness, wallHeight, wallThickness),
                wallMaterial
            );
            southWall.position.set(0, wallHeight/2, citySize/2);
            scene.add(southWall);
            walls.push(southWall);

            // East wall
            const eastWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, groundSize + wallThickness),
                wallMaterial
            );
            eastWall.position.set(citySize/2, wallHeight/2, 0);
            scene.add(eastWall);
            walls.push(eastWall);

            // West wall
            const westWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, groundSize + wallThickness),
                wallMaterial
            );
            westWall.position.set(-citySize/2, wallHeight/2, 0);
            scene.add(westWall);
            walls.push(westWall);

            // Add decorative elements to walls
            walls.forEach(wall => {
                // Add pillars at intervals
                const pillarSpacing = 5;  // Increased spacing for larger area
                const pillarSize = 0.4;
                const pillarHeight = wallHeight + 0.8;
                const pillarGeometry = new THREE.BoxGeometry(pillarSize, pillarHeight, pillarSize);
                const pillarMaterial = new THREE.MeshStandardMaterial({
                    color: 0xE5E5E5,
                    metalness: 0.3,
                    roughness: 0.7
                });

                const isHorizontal = wall.geometry.parameters.width > wall.geometry.parameters.depth;
                const length = isHorizontal ? wall.geometry.parameters.width : wall.geometry.parameters.depth;
                const numPillars = Math.floor(length / pillarSpacing) - 1;

                for (let i = -numPillars/2; i <= numPillars/2; i++) {
                    const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                    pillar.position.y = wallHeight/2;
                    
                    if (isHorizontal) {
                        pillar.position.x = i * pillarSpacing;
                        pillar.position.z = wall.position.z;
                    } else {
                        pillar.position.x = wall.position.x;
                        pillar.position.z = i * pillarSpacing;
                    }
                    
                    scene.add(pillar);
                }
            });

            return walls;
        }

        // Add isMobile helper function
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                || window.innerWidth <= 768;
        }

        // Add these functions at the beginning of your script
        async function updateGameCounter() {
            const counterRef = db.ref('gameCounter');
            await counterRef.transaction((currentCount) => (currentCount || 0) + 1);
        }

        async function saveScore(username, score) {
            const scoresRef = db.ref('highScores');
            const newScore = {
                username: username || 'Anonymous',
                score: score,
                timestamp: Date.now()
            };
            await scoresRef.push(newScore);

            // Keep only top 100 scores
            const scoresSnapshot = await scoresRef.orderByChild('score').limitToLast(100).once('value');
            const scores = [];
            scoresSnapshot.forEach((childSnapshot) => {
                scores.push({
                    id: childSnapshot.key,
                    ...childSnapshot.val()
                });
            });
            return scores.reverse();
        }

        async function getHighScores() {
            const scoresRef = db.ref('highScores');
            const snapshot = await scoresRef.orderByChild('score').limitToLast(10).once('value');
            const scores = [];
            snapshot.forEach((childSnapshot) => {
                scores.push(childSnapshot.val());
            });
            return scores.reverse();
        }

        // Update the game over function
        function gameOver() {
            const finalScore = score;
            const username = prompt('Game Over! Enter your name for the high scores:');
            
            saveScore(username, finalScore).then(() => {
                showHighScores();
            });
            
            updateGameCounter();  // Update the global game counter
            
            // Reset game state
            score = 0;
            gameStarted = false;
            // ... rest of your existing game over code ...
        }

        // Update the showHighScores function
        async function showHighScores() {
            const scoresDiv = document.createElement('div');
            scoresDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                padding: 20px;
                border-radius: 10px;
                color: white;
                text-align: center;
                min-width: 300px;
                z-index: 1000;
            `;

            let content = '<h2 style="color: #E23744;">üèÜ High Scores üèÜ</h2>';
            
            // Get total games played
            const counterSnapshot = await db.ref('gameCounter').once('value');
            const totalGames = counterSnapshot.val() || 0;
            content += `<p style="color: #FFD700;">Total Games Played Globally: ${totalGames}</p>`;

            // Get high scores
            const highScores = await getHighScores();

            // ... rest of your existing showHighScores code ...
        }
    </script>
    <!-- Add message queue container to the body -->
    <div id="message-queue" style="
        position: fixed;
        left: 20px;
        top: 150px;
        width: 400px;
        z-index: 1000;
    "></div>
</body>
</html>